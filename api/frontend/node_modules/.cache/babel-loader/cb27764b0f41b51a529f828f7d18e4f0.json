{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { MessageHeader } from '../enum';\nimport { flatbuffers } from 'flatbuffers';\nvar ByteBuffer = flatbuffers.ByteBuffer;\nimport { Message } from './metadata/message';\nimport { isFileHandle } from '../util/compat';\nimport { AsyncRandomAccessFile } from '../io/file';\nimport { toUint8Array } from '../util/buffer';\nimport { ByteStream, AsyncByteStream } from '../io/stream';\nimport { ArrowJSON, ITERATOR_DONE } from '../io/interfaces';\n/** @ignore */\n\nconst invalidMessageType = type => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;\n/** @ignore */\n\n\nconst nullMessage = type => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;\n/** @ignore */\n\n\nconst invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\n/** @ignore */\n\n\nconst invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\n/** @ignore */\n\n\nexport class MessageReader {\n  constructor(source) {\n    this.source = source instanceof ByteStream ? source : new ByteStream(source);\n  }\n\n  [Symbol.iterator]() {\n    return this;\n  }\n\n  next() {\n    let r;\n\n    if ((r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    } // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n    // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n    // pre-v0.15 message, where the first 4 bytes are the metadata length.\n\n\n    if (r.value === -1 && (r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n\n    if ((r = this.readMetadata(r.value)).done) {\n      return ITERATOR_DONE;\n    }\n\n    return r;\n  }\n\n  throw(value) {\n    return this.source.throw(value);\n  }\n\n  return(value) {\n    return this.source.return(value);\n  }\n\n  readMessage(type) {\n    let r;\n\n    if ((r = this.next()).done) {\n      return null;\n    }\n\n    if (type != null && r.value.headerType !== type) {\n      throw new Error(invalidMessageType(type));\n    }\n\n    return r.value;\n  }\n\n  readMessageBody(bodyLength) {\n    if (bodyLength <= 0) {\n      return new Uint8Array(0);\n    }\n\n    const buf = toUint8Array(this.source.read(bodyLength));\n\n    if (buf.byteLength < bodyLength) {\n      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n    } // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n    // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n\n\n    return (\n      /* 1. */\n      buf.byteOffset % 8 === 0 &&\n      /* 2. */\n      buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()\n    );\n  }\n\n  readSchema(throwIfNull = false) {\n    const type = MessageHeader.Schema;\n    const message = this.readMessage(type);\n    const schema = message && message.header();\n\n    if (throwIfNull && !schema) {\n      throw new Error(nullMessage(type));\n    }\n\n    return schema;\n  }\n\n  readMetadataLength() {\n    const buf = this.source.read(PADDING);\n    const bb = buf && new ByteBuffer(buf);\n    const len = bb && bb.readInt32(0) || 0;\n    return {\n      done: len === 0,\n      value: len\n    };\n  }\n\n  readMetadata(metadataLength) {\n    const buf = this.source.read(metadataLength);\n\n    if (!buf) {\n      return ITERATOR_DONE;\n    }\n\n    if (buf.byteLength < metadataLength) {\n      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n    }\n\n    return {\n      done: false,\n      value: Message.decode(buf)\n    };\n  }\n\n}\n/** @ignore */\n\nexport class AsyncMessageReader {\n  constructor(source, byteLength) {\n    this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);\n  }\n\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n\n  async next() {\n    let r;\n\n    if ((r = await this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    } // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n    // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n    // pre-v0.15 message, where the first 4 bytes are the metadata length.\n\n\n    if (r.value === -1 && (r = await this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n\n    if ((r = await this.readMetadata(r.value)).done) {\n      return ITERATOR_DONE;\n    }\n\n    return r;\n  }\n\n  async throw(value) {\n    return await this.source.throw(value);\n  }\n\n  async return(value) {\n    return await this.source.return(value);\n  }\n\n  async readMessage(type) {\n    let r;\n\n    if ((r = await this.next()).done) {\n      return null;\n    }\n\n    if (type != null && r.value.headerType !== type) {\n      throw new Error(invalidMessageType(type));\n    }\n\n    return r.value;\n  }\n\n  async readMessageBody(bodyLength) {\n    if (bodyLength <= 0) {\n      return new Uint8Array(0);\n    }\n\n    const buf = toUint8Array(await this.source.read(bodyLength));\n\n    if (buf.byteLength < bodyLength) {\n      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n    } // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n    // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n\n\n    return (\n      /* 1. */\n      buf.byteOffset % 8 === 0 &&\n      /* 2. */\n      buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()\n    );\n  }\n\n  async readSchema(throwIfNull = false) {\n    const type = MessageHeader.Schema;\n    const message = await this.readMessage(type);\n    const schema = message && message.header();\n\n    if (throwIfNull && !schema) {\n      throw new Error(nullMessage(type));\n    }\n\n    return schema;\n  }\n\n  async readMetadataLength() {\n    const buf = await this.source.read(PADDING);\n    const bb = buf && new ByteBuffer(buf);\n    const len = bb && bb.readInt32(0) || 0;\n    return {\n      done: len === 0,\n      value: len\n    };\n  }\n\n  async readMetadata(metadataLength) {\n    const buf = await this.source.read(metadataLength);\n\n    if (!buf) {\n      return ITERATOR_DONE;\n    }\n\n    if (buf.byteLength < metadataLength) {\n      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n    }\n\n    return {\n      done: false,\n      value: Message.decode(buf)\n    };\n  }\n\n}\n/** @ignore */\n\nexport class JSONMessageReader extends MessageReader {\n  constructor(source) {\n    super(new Uint8Array(0));\n    this._schema = false;\n    this._body = [];\n    this._batchIndex = 0;\n    this._dictionaryIndex = 0;\n    this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);\n  }\n\n  next() {\n    const {\n      _json\n    } = this;\n\n    if (!this._schema) {\n      this._schema = true;\n      const message = Message.fromJSON(_json.schema, MessageHeader.Schema);\n      return {\n        done: false,\n        value: message\n      };\n    }\n\n    if (this._dictionaryIndex < _json.dictionaries.length) {\n      const batch = _json.dictionaries[this._dictionaryIndex++];\n      this._body = batch['data']['columns'];\n      const message = Message.fromJSON(batch, MessageHeader.DictionaryBatch);\n      return {\n        done: false,\n        value: message\n      };\n    }\n\n    if (this._batchIndex < _json.batches.length) {\n      const batch = _json.batches[this._batchIndex++];\n      this._body = batch['columns'];\n      const message = Message.fromJSON(batch, MessageHeader.RecordBatch);\n      return {\n        done: false,\n        value: message\n      };\n    }\n\n    this._body = [];\n    return ITERATOR_DONE;\n  }\n\n  readMessageBody(_bodyLength) {\n    return flattenDataSources(this._body);\n\n    function flattenDataSources(xs) {\n      return (xs || []).reduce((buffers, column) => [...buffers, ...(column['VALIDITY'] && [column['VALIDITY']] || []), ...(column['TYPE'] && [column['TYPE']] || []), ...(column['OFFSET'] && [column['OFFSET']] || []), ...(column['DATA'] && [column['DATA']] || []), ...flattenDataSources(column['children'])], []);\n    }\n  }\n\n  readMessage(type) {\n    let r;\n\n    if ((r = this.next()).done) {\n      return null;\n    }\n\n    if (type != null && r.value.headerType !== type) {\n      throw new Error(invalidMessageType(type));\n    }\n\n    return r.value;\n  }\n\n  readSchema() {\n    const type = MessageHeader.Schema;\n    const message = this.readMessage(type);\n    const schema = message && message.header();\n\n    if (!message || !schema) {\n      throw new Error(nullMessage(type));\n    }\n\n    return schema;\n  }\n\n}\n/** @ignore */\n\nexport const PADDING = 4;\n/** @ignore */\n\nexport const MAGIC_STR = 'ARROW1';\n/** @ignore */\n\nexport const MAGIC = new Uint8Array(MAGIC_STR.length);\n\nfor (let i = 0; i < MAGIC_STR.length; i += 1 | 0) {\n  MAGIC[i] = MAGIC_STR.charCodeAt(i);\n}\n/** @ignore */\n\n\nexport function checkForMagicArrowString(buffer, index = 0) {\n  for (let i = -1, n = MAGIC.length; ++i < n;) {\n    if (MAGIC[i] !== buffer[index + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/** @ignore */\n\nexport const magicLength = MAGIC.length;\n/** @ignore */\n\nexport const magicAndPadding = magicLength + PADDING;\n/** @ignore */\n\nexport const magicX2AndPadding = magicLength * 2 + PADDING;","map":{"version":3,"sources":["ipc/message.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { MessageHeader } from '../enum';\nimport { flatbuffers } from 'flatbuffers';\nimport ByteBuffer = flatbuffers.ByteBuffer;\nimport { Message } from './metadata/message';\nimport { isFileHandle } from '../util/compat';\nimport { AsyncRandomAccessFile } from '../io/file';\nimport { toUint8Array, ArrayBufferViewInput } from '../util/buffer';\nimport { ByteStream, ReadableSource, AsyncByteStream } from '../io/stream';\nimport { ArrowJSON, ArrowJSONLike, ITERATOR_DONE, FileHandle } from '../io/interfaces';\n\n/** @ignore */ const invalidMessageType       = (type: MessageHeader) => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;\n/** @ignore */ const nullMessage              = (type: MessageHeader) => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;\n/** @ignore */ const invalidMessageMetadata   = (expected: number, actual: number) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\n/** @ignore */ const invalidMessageBodyLength = (expected: number, actual: number) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\n\n/** @ignore */\nexport class MessageReader implements IterableIterator<Message> {\n    protected source: ByteStream;\n    constructor(source: ByteStream | ArrayBufferViewInput | Iterable<ArrayBufferViewInput>) {\n        this.source = source instanceof ByteStream ? source : new ByteStream(source);\n    }\n    public [Symbol.iterator](): IterableIterator<Message> { return this as IterableIterator<Message>; }\n    public next(): IteratorResult<Message> {\n        let r;\n        if ((r = this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n        // pre-v0.15 message, where the first 4 bytes are the metadata length.\n        if ((r.value === -1) &&\n            (r = this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        if ((r = this.readMetadata(r.value)).done) { return ITERATOR_DONE; }\n        return (<any> r) as IteratorResult<Message>;\n    }\n    public throw(value?: any) { return this.source.throw(value); }\n    public return(value?: any) { return this.source.return(value); }\n    public readMessage<T extends MessageHeader>(type?: T | null) {\n        let r: IteratorResult<Message<T>>;\n        if ((r = this.next()).done) { return null; }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    public readMessageBody(bodyLength: number): Uint8Array {\n        if (bodyLength <= 0) { return new Uint8Array(0); }\n        const buf = toUint8Array(this.source.read(bodyLength));\n        if (buf.byteLength < bodyLength) {\n            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n        }\n        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n        return /* 1. */ (buf.byteOffset % 8 === 0) &&\n               /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();\n    }\n    public readSchema(throwIfNull = false) {\n        const type = MessageHeader.Schema;\n        const message = this.readMessage(type);\n        const schema = message && message.header();\n        if (throwIfNull && !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n    protected readMetadataLength(): IteratorResult<number> {\n        const buf = this.source.read(PADDING);\n        const bb = buf && new ByteBuffer(buf);\n        const len = bb && bb.readInt32(0) || 0;\n        return { done: len === 0, value: len };\n    }\n    protected readMetadata(metadataLength: number): IteratorResult<Message> {\n        const buf = this.source.read(metadataLength);\n        if (!buf) { return ITERATOR_DONE; }\n        if (buf.byteLength < metadataLength) {\n            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n        }\n        return { done: false, value: Message.decode(buf) };\n    }\n}\n\n/** @ignore */\nexport class AsyncMessageReader implements AsyncIterableIterator<Message> {\n    protected source: AsyncByteStream;\n    constructor(source: ReadableSource<Uint8Array>);\n    constructor(source: FileHandle, byteLength?: number);\n    constructor(source: any, byteLength?: number) {\n        this.source = source instanceof AsyncByteStream ? source\n            : isFileHandle(source)\n            ? new AsyncRandomAccessFile(source, byteLength!)\n            : new AsyncByteStream(source);\n    }\n    public [Symbol.asyncIterator](): AsyncIterableIterator<Message> { return this as AsyncIterableIterator<Message>; }\n    public async next(): Promise<IteratorResult<Message>> {\n        let r;\n        if ((r = await this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n        // pre-v0.15 message, where the first 4 bytes are the metadata length.\n        if ((r.value === -1) &&\n            (r = await this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        if ((r = await this.readMetadata(r.value)).done) { return ITERATOR_DONE; }\n        return (<any> r) as IteratorResult<Message>;\n    }\n    public async throw(value?: any) { return await this.source.throw(value); }\n    public async return(value?: any) { return await this.source.return(value); }\n    public async readMessage<T extends MessageHeader>(type?: T | null) {\n        let r: IteratorResult<Message<T>>;\n        if ((r = await this.next()).done) { return null; }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    public async readMessageBody(bodyLength: number): Promise<Uint8Array> {\n        if (bodyLength <= 0) { return new Uint8Array(0); }\n        const buf = toUint8Array(await this.source.read(bodyLength));\n        if (buf.byteLength < bodyLength) {\n            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n        }\n        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n        return /* 1. */ (buf.byteOffset % 8 === 0) &&\n               /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();\n    }\n    public async readSchema(throwIfNull = false) {\n        const type = MessageHeader.Schema;\n        const message = await this.readMessage(type);\n        const schema = message && message.header();\n        if (throwIfNull && !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n    protected async readMetadataLength(): Promise<IteratorResult<number>> {\n        const buf = await this.source.read(PADDING);\n        const bb = buf && new ByteBuffer(buf);\n        const len = bb && bb.readInt32(0) || 0;\n        return { done: len === 0, value: len };\n    }\n    protected async readMetadata(metadataLength: number): Promise<IteratorResult<Message>> {\n        const buf = await this.source.read(metadataLength);\n        if (!buf) { return ITERATOR_DONE; }\n        if (buf.byteLength < metadataLength) {\n            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n        }\n        return { done: false, value: Message.decode(buf) };\n    }\n}\n\n/** @ignore */\nexport class JSONMessageReader extends MessageReader {\n    private _schema = false;\n    private _json: ArrowJSON;\n    private _body: any[] = [];\n    private _batchIndex = 0;\n    private _dictionaryIndex = 0;\n    constructor(source: ArrowJSON | ArrowJSONLike) {\n        super(new Uint8Array(0));\n        this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);\n    }\n    public next() {\n        const { _json } = this;\n        if (!this._schema) {\n            this._schema = true;\n            const message = Message.fromJSON(_json.schema, MessageHeader.Schema);\n            return { done: false, value: message };\n        }\n        if (this._dictionaryIndex < _json.dictionaries.length) {\n            const batch = _json.dictionaries[this._dictionaryIndex++];\n            this._body = batch['data']['columns'];\n            const message = Message.fromJSON(batch, MessageHeader.DictionaryBatch);\n            return { done: false, value: message };\n        }\n        if (this._batchIndex < _json.batches.length) {\n            const batch = _json.batches[this._batchIndex++];\n            this._body = batch['columns'];\n            const message = Message.fromJSON(batch, MessageHeader.RecordBatch);\n            return { done: false, value: message };\n        }\n        this._body = [];\n        return ITERATOR_DONE;\n    }\n    public readMessageBody(_bodyLength?: number) {\n        return flattenDataSources(this._body) as any;\n        function flattenDataSources(xs: any[]): any[][] {\n            return (xs || []).reduce<any[][]>((buffers, column: any) => [\n                ...buffers,\n                ...(column['VALIDITY'] && [column['VALIDITY']] || []),\n                ...(column['TYPE'] && [column['TYPE']] || []),\n                ...(column['OFFSET'] && [column['OFFSET']] || []),\n                ...(column['DATA'] && [column['DATA']] || []),\n                ...flattenDataSources(column['children'])\n            ], [] as any[][]);\n        }\n    }\n    public readMessage<T extends MessageHeader>(type?: T | null) {\n        let r: IteratorResult<Message<T>>;\n        if ((r = this.next()).done) { return null; }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    public readSchema() {\n        const type = MessageHeader.Schema;\n        const message = this.readMessage(type);\n        const schema = message && message.header();\n        if (!message || !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n}\n\n/** @ignore */\nexport const PADDING = 4;\n/** @ignore */\nexport const MAGIC_STR = 'ARROW1';\n/** @ignore */\nexport const MAGIC = new Uint8Array(MAGIC_STR.length);\n\nfor (let i = 0; i < MAGIC_STR.length; i += 1 | 0) {\n    MAGIC[i] = MAGIC_STR.charCodeAt(i);\n}\n\n/** @ignore */\nexport function checkForMagicArrowString(buffer: Uint8Array, index = 0) {\n    for (let i = -1, n = MAGIC.length; ++i < n;) {\n        if (MAGIC[i] !== buffer[index + i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/** @ignore */\nexport const magicLength = MAGIC.length;\n/** @ignore */\nexport const magicAndPadding = magicLength + PADDING;\n/** @ignore */\nexport const magicX2AndPadding = magicLength * 2 + PADDING;\n"]},"metadata":{},"sourceType":"module"}